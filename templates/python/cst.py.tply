{!
from magelang.lang.python.emitter import emit
!}

from typing import TypeAlias, TypeGuard, Any

class TextPos:

    def __init__(self, offset: int, line: int, column: int) -> None:
        self.offset = offset
        self.line = line
        self.column = column

class Span:

    def __init__(self, start_offset: int, end_offset: int) -> None:
        self.start_offset = start_offset
        self.end_offset = end_offset

    def __len__(self) -> int:
        return self.end_offset - self.start_offset

class Token:

    def __init__(self, span: Span | None = None) -> None:
        self.span = span

class Node:

    def __init__(self) -> None:
        pass

{!

def gen_init_body(field_name: str, field_type: Type, in_name: str, assign: Callable[[PyExpr], PyStmt], stmts: list[PyStmt]) -> Type:

    def visit(ty: Type, in_name: str, assign: Callable[[PyExpr], PyStmt], stmts: list[PyStmt], has_none: bool) -> tuple[Type, bool]:
        """
        This function returns a new type and a boolean indicating whether any coercions have been added.
        """

        if isinstance(ty, NodeType):
            #assert(ty == orig_ty)
            coerced_types: list[Type] = []
            coerced_types.append(ty)
            # FIXME this should probably be behind an if-statemnet
            stmts.append(assign(PyNamedExpr(name=in_name)))
            spec = specs.lookup(ty.name)
            coercable = False
            # spec can also be a VariantSpec so we need to run isinstance
            if isinstance(spec, NodeSpec) and len(spec.members) == 1:
                # TODO maybe also coerce spec.members[0].ty?
                coercable = True
                first_ty = spec.members[0].ty
                if_body: list[PyStmt] = []
                if_body.append(assign(PyCallExpr(operator=PyNamedExpr(name=to_class_case(ty.name)), args=list([ (PyNamedExpr(name=in_name), None) ]))))
                stmts.append(PyIfStmt(first=PyIfCase(test=gen_shallow_test(first_ty, PyNamedExpr(name=in_name)), body=if_body)))
                coerced_types.append(first_ty)
            return UnionType(coerced_types), coercable

        if isinstance(ty, NoneType):
            stmts.append(assign(PyNamedExpr(name='None')))
            return ty, False

        if isinstance(ty, TokenType):
            coerced_types = []
            coerced_types.append(ty)
            spec = specs.lookup(ty.name)
            assert(isinstance(spec, TokenSpec))
            cases: list[Case] = []
            if spec.is_static:
                if not has_none:
                    coerced_types.append(NoneType())
                    cases.append((
                        PyInfixExpr(left=PyNamedExpr(name=in_name), op='is', right=PyNamedExpr(name='None')),
                        [ assign(PyCallExpr(operator=PyNamedExpr(name=to_class_case(ty.name)), args=[])) ]
                    ))
            else:
                coerced_types.append(ExternType(spec.field_type))
                # out_name = Token(in_name)
                cases.append((
                    gen_rule_type_test(spec.field_type, PyNamedExpr(name=in_name)),
                    [ assign(PyCallExpr(operator=PyNamedExpr(name=to_class_case(ty.name)), args=[ (PyNamedExpr(name=in_name), None) ])) ]
                ))
            # out_name = in_name
            cases.append((None, [ assign(PyNamedExpr(name=in_name)) ]))
            stmts.extend(make_cond(cases))
            return UnionType(coerced_types), True 

        if isinstance(ty, ListType):
            # out_name = list()
            # for element in in_name:
            #     ...
            #     out_name.append(new_element_name)
            coercable_types: list[Type] = []
            cases: list[Case] = []
            orelse: list[PyStmt] = []
            for_body: list[PyStmt] = []

            new_elements_name = f'new_{in_name}'
            element_name = f'{in_name}_element'
            new_element_name = f'new_{in_name}_element'

            if not has_none:
                coercable_types.append(NoneType())
                cases.append((
                    PyInfixExpr(left=PyNamedExpr(name=in_name), op='is', right=PyNamedExpr(name='None')),
                    [ assign(PyCallExpr(operator=PyNamedExpr(name='list'))) ]
                ))

            orelse.append(PyAssignStmt(pattern=PyNamedPattern(name=new_elements_name), expr=PyCallExpr(operator=PyNamedExpr(name='list'))))

            element_assign: Callable[[PyExpr], PyStmt] = lambda value, name=new_element_name: PyAssignStmt(pattern=PyNamedPattern(name=name), expr=value)
            element_type, element_coercable = visit(ty.element_type, element_name, element_assign, for_body, False)

            coercable_types.append(ListType(element_type))

            for_body.append(PyExprStmt(expr=PyCallExpr(operator=PyAttrExpr(expr=PyNamedExpr(name=new_elements_name), name='append'), args=[ (PyNamedExpr(name=new_element_name), None) ])))
            orelse.append(PyForStmt(pattern=PyNamedPattern(name=element_name), expr=PyNamedExpr(name=in_name), body=for_body))

            orelse.append(assign(PyNamedExpr(name=new_elements_name)))

            cases.append((
                None,
                orelse
            ))

            stmts.extend(make_cond(cases))

            return UnionType(coercable_types), True

        if isinstance(ty, TupleType):

            # element_0 = field[0]
            # new_element_0 = ...
            # ...
            # out_name = (new_element_0, new_element_1, ...)

            coercable = False
            coerced_types: list[Type] = []
            cases: list[Case] = []
            required: list[Type] = []

            for element_type in ty.element_types:
                if not is_default_constructible(element_type, allow_empty_lists=False):
                    required.append(element_type)

            if len(required) == 1:

                case_body: list[PyStmt] = []

                first_type = required[0]

                coercable = True
                def first_assign(value: PyExpr):
                    assert(isinstance(ty, TupleType)) # Needed to keep Pyright happy
                    return assign(PyTupleExpr(elements=list_comma(value if el_ty == first_type else gen_default_constructor(el_ty) for el_ty in ty.element_types)))
                new_first_type, _ = visit(first_type, in_name, first_assign, case_body, False)
                coerced_types.append(new_first_type)
                cases.append((
                    gen_shallow_test(first_type, PyNamedExpr(name=in_name)),
                    case_body
                ))

            orelse: list[PyStmt] = []
            new_elements: list[PyExpr] = []
            new_element_types: list[Type] = []

            orelse.append(PyExprStmt(expr=PyCallExpr(operator=PyNamedExpr(name='assert'), args=[ (gen_shallow_test(ty, PyNamedExpr(name=in_name)), None) ])))

            for i, element_type in enumerate(ty.element_types):

                element_name = f'{in_name}_{i}'
                new_element_name = f'new_{in_name}_{i}'
                element_assign = lambda value, name=new_element_name: PyAssignStmt(pattern=PyNamedPattern(name=name), expr=value)

                new_elements.append(PyNamedExpr(name=new_element_name))

                orelse.append(PyAssignStmt(pattern=PyNamedPattern(name=element_name), expr=PySubscriptExpr(expr=PyNamedExpr(name=in_name), slices=list([ (PyConstExpr(literal=i), None) ]))))

                new_element_type, element_coercable = visit(element_type, element_name, element_assign, orelse, False)

                if element_coercable:
                    coercable = True

                new_element_types.append(new_element_type)


            orelse.append(assign(PyTupleExpr(elements=list_comma(new_elements))))
            cases.append((None, orelse))
            coerced_types.append(TupleType(new_element_types))

            stmts.extend(make_cond(cases))

            return UnionType(coerced_types), coercable

        if isinstance(ty, UnionType):

            coercable = False
            coerced_types: list[Type] = []
            cases: list[Case] = []

            for element_type in ty.types:
                if isinstance(element_type, NoneType):
                    has_none = True
                    break

            for element_type in ty.types:
                body: list[PyStmt] = [] 
                new_type, element_coercable = visit(element_type, in_name, assign, body, has_none)
                if element_coercable:
                    coercable = True
                coerced_types.append(new_type)
                cases.append((
                    gen_shallow_test(new_type, PyNamedExpr(name=in_name)),
                    body
                ))

            # TODO ensure duplicate types are eliminated
            # if len(not_none) == 1 and is_default_constructible(not_none[0]):
            #     cases.append((
            #         None,
            #         [ assign(gen_default_constructor(ty.types[0])) ]
            #     ))
            # else:
            cases.append((
                None,
                list([ PyRaiseStmt(expr=PyCallExpr(operator=PyNamedExpr(name='ValueError'), args=[ (PyConstExpr(literal=f"the field '{field_name}' received an unrecognised value'"), None) ])) ])
            ))

            if coercable:
                stmts.extend(make_cond(cases))
            else:
                stmts.append(assign(PyNamedExpr(name=in_name)))

            # ty_0 = ty.types[0]
            # ty_n = ty.types[1:]
            # if_body = []
            # new_ty_0 = visit(ty_0, in_name, out_name, if_body)
            # if_orelse = []
            # new_rest = visit(UnionType(ty_n), in_name, out_name, if_orelse)
            # stmts.append(ast.If(test=gen_shallow_test(ty_0, PyNamedExpr(name=in_name)), body=if_body, orelse=if_orelse))

            return UnionType(coerced_types), coercable

        raise RuntimeError(f'unexpected {ty}')

    ty, _ = visit(field_type, in_name, assign, stmts, False)
    return ty

stmts: list[PyStmt] = []

for spec in specs:

    if isinstance(spec, NodeSpec):

        body: list[PyStmt] = []
        params: list[PyParam] = []
        init_body: list[PyStmt] = []

        for field in spec.members:

            assign: Callable[[PyExpr], PyStmt] = lambda value, field=field: PyAssignStmt(pattern=PyAttrPattern(pattern=PyNamedPattern(name='self'), name=field.name), annotation=gen_type(field.ty), expr=value)
            param_type = gen_init_body(field.name, field.ty, field.name, assign, init_body)

            param_type_str = emit(gen_type(param_type))
            params.append(PyNamedParam(
                pattern=PyNamedPattern(name=field.name),
                annotation=PyConstExpr(literal=param_type_str),
                default=PyNamedExpr(name='None') if is_optional(param_type) else None
            ))

        body.append(PyFuncDef(
            name='__init__',
            params=list_comma([ PyNamedParam(pattern=PyNamedPattern(name='self')), PySepParam(), *params ]),
            return_type=PyNamedExpr(name='None'),
            body=init_body
        ))

        stmts.append(PyClassDef(name=to_class_case(spec.name), bases=[ ('Node', None) ], body=body))

        continue

    if isinstance(spec, TokenSpec):

        body = []

        if spec.is_static:

            body.append(PyPassStmt())

        else:

            init_body = []

            init_body.append(PyExprStmt(expr=PyCallExpr(operator=PyAttrExpr(expr=PyCallExpr(operator=PyNamedExpr(name='super')), name='__init__'), args=[ (PyKeywordArg(name='span', expr=PyNamedExpr(name='span')), None) ])))

            params: list[PyParam] = []
            params.append(PyNamedParam(pattern=PyNamedPattern(name='self')))

            # value: Field | None = None
            params.append(PyNamedParam(pattern=PyNamedPattern(name='value'), annotation=make_bitor([ rule_type_to_py_type(spec.field_type), PyNamedExpr(name='None') ]), default=PyNamedExpr(name='None')))

            # span: Span | None = None
            params.append(PyNamedParam(pattern=PyNamedPattern(name='span'), annotation=make_bitor([ PyNamedExpr(name='Span'), PyNamedExpr(name='None') ]), default=PyNamedExpr(name='None')))

            init_body.append(PyAssignStmt(pattern=PyAttrPattern(pattern=PyNamedPattern(name='self'), name='value'), expr=PyNamedExpr(name='value')))

            body.append(PyFuncDef(name='__init__', params=list_comma(params), body=init_body))

        stmts.append(PyClassDef(name=to_class_case(spec.name), bases=[ ('Token', None) ], body=body))

        continue

    if isinstance(spec, VariantSpec):

        cls_name = to_class_case(spec.name)

        assert(len(spec.members) > 0)
        py_type = PyConstExpr(literal=emit(make_bitor(PyNamedExpr(name=to_class_case(name)) for name in spec.members)))
        stmts.append(PyAssignStmt(pattern=PyNamedPattern(name=cls_name), annotation=PyNamedExpr(name='TypeAlias'), expr=py_type))

        params = []
        params.append(PyNamedParam(pattern=PyNamedPattern(name='value'), annotation=PyNamedExpr(name='Any')))
        stmts.append(PyFuncDef(
            name=f'is_{namespace(spec.name)}',
            params=list_comma(params),
            return_type=PySubscriptExpr(expr=PyNamedExpr(name='TypeGuard'), slices=[ (PyNamedExpr(name=cls_name), None) ]),
            body=[
                PyRetStmt(expr=make_or(gen_instance_check(name, PyNamedExpr(name='value')) for name in spec.members))
            ],
        ))

        continue

    assert_never(spec)

write(emit(PyModule(stmts=stmts)))

!}
